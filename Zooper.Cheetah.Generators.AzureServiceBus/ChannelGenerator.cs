using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Zooper.Cheetah.Generators.AzureServiceBus;

[Generator]
public sealed class ChannelGenerator : IIncrementalGenerator
{
	private const string FileName = "MassTransitChannelRegistration";
	private const string Namespace = "Zooper.Cheetah.Generators.AzureServiceBus";
	private const string ClassName = "MassTransitChannelRegistration";
	private const string MethodName = "ConfigureChannels";
	private const string ChannelAttributeName = "Zooper.Cheetah.Attributes.ChannelAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Register a syntax provider that filters for class declarations with attributes
		var channelClasses = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: IsSyntaxTargetForGeneration, // Filter syntax nodes
				transform: GetSemanticTargetForGeneration // Transform to semantic symbols
			)
			.Where(static classSymbol => classSymbol != null)!; // Filter out nulls

		// Combine the compilation with the collected channel symbols
		var compilationAndChannels = context.CompilationProvider.Combine(channelClasses.Collect());

		// Register the source output
		context.RegisterSourceOutput(
			compilationAndChannels,
			(
				spc,
				source) => Execute(source.Left, source.Right, spc)
		);
	}

	/// <summary>
	/// Predicate to identify candidate classes with attributes.
	/// </summary>
	private static bool IsSyntaxTargetForGeneration(
		SyntaxNode node,
		CancellationToken cancellationToken)
	{
		return node is ClassDeclarationSyntax classDeclaration &&
		       classDeclaration.AttributeLists.Count > 0;
	}

	/// <summary>
	/// Transforms a syntax node into a semantic symbol if it has attributes.
	/// </summary>
	private static INamedTypeSymbol? GetSemanticTargetForGeneration(
		GeneratorSyntaxContext context,
		CancellationToken cancellationToken)
	{
		var classDeclaration = (ClassDeclarationSyntax)context.Node;
		var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration, cancellationToken) as INamedTypeSymbol;

		if (classSymbol == null)
			return null;

		var channelAttributeSymbol = context.SemanticModel.Compilation.GetTypeByMetadataName(ChannelAttributeName);
		if (channelAttributeSymbol == null)
			return null;

		// Check if the class has the ChannelAttribute using symbol comparison
		foreach (var attribute in classSymbol.GetAttributes())
		{
			if (attribute.AttributeClass == null)
				continue;

			if (SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, channelAttributeSymbol))
			{
				return classSymbol;
			}
		}

		return null;
	}

	/// <summary>
	/// Executes the generation logic.
	/// </summary>
	private static void Execute(
		Compilation compilation,
		ImmutableArray<INamedTypeSymbol?> channels,
		SourceProductionContext context)
	{
		if (channels.IsDefaultOrEmpty)
			return;

		// Retrieve the ChannelAttribute symbol using fully qualified string name
		var channelAttributeSymbol =
			compilation.GetTypeByMetadataName(ChannelAttributeName);

		if (channelAttributeSymbol == null)
		{
			// Attribute not found; nothing to generate
			return;
		}

		// Collect all channel information
		var channelInfos = new List<ChannelInfo>();

		foreach (var classSymbol in channels.Distinct())
		{
			if (classSymbol == null)
				continue;

			// Retrieve the ChannelAttribute data using symbol comparison
			var attributeData = classSymbol.GetAttributes()
				.FirstOrDefault(ad => SymbolEqualityComparer.Default.Equals(ad.AttributeClass, channelAttributeSymbol));

			if (attributeData == null)
				continue;

			// Extract channel name from the ChannelAttribute
			var channelName = attributeData.ConstructorArguments.Length > 0 ? attributeData.ConstructorArguments[0].Value as string : null;

			if (channelName is null)
				continue;

			channelInfos.Add(
				new ChannelInfo
				{
					EventName = classSymbol.ToDisplayString(),
					ChannelName = channelName
				}
			);
		}

		if (channelInfos.Count == 0)
			return;

		// Generate the channel registration code
		var sourceBuilder = new StringBuilder();
		AppendUsings(sourceBuilder);
		AppendNamespace(sourceBuilder);
		AppendClass(sourceBuilder, channelInfos);

		// Add the generated source to the compilation
		context.AddSource($"{FileName}.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
	}

	private static void AppendUsings(StringBuilder sourceBuilder)
	{
		sourceBuilder.AppendLine("// <auto-generated/>");
		sourceBuilder.AppendLine("using System;");
		sourceBuilder.AppendLine("using System.Collections.Generic;");
		sourceBuilder.AppendLine("using MassTransit;");
		sourceBuilder.AppendLine();
	}

	private static void AppendNamespace(StringBuilder sourceBuilder)
	{
		sourceBuilder.AppendLine($"namespace {Namespace};");
		sourceBuilder.AppendLine();
	}

	private static void AppendClass(
		StringBuilder sourceBuilder,
		List<ChannelInfo> channels)
	{
		sourceBuilder.AppendLine($"public static class {ClassName}");
		sourceBuilder.AppendLine("{");
		AppendMethod(sourceBuilder, channels);
		sourceBuilder.AppendLine("}");
	}

	private static void AppendMethod(
		StringBuilder sourceBuilder,
		List<ChannelInfo> channels)
	{
		sourceBuilder.AppendLine($"    public static void {MethodName}(IServiceBusBusFactoryConfigurator configurator)");
		sourceBuilder.AppendLine("    {");
		AppendChannelList(sourceBuilder, channels);
		sourceBuilder.AppendLine("    }");
	}

	private static void AppendChannelList(
		StringBuilder sourceBuilder,
		List<ChannelInfo> channels)
	{
		foreach (var channel in channels)
		{
			AppendChannelRegistration(sourceBuilder, channel);
		}
	}

	private static void AppendChannelRegistration(
		StringBuilder sourceBuilder,
		ChannelInfo channel)
	{
		sourceBuilder.AppendLine($"        configurator.ReceiveEndpoint(\"{channel.ChannelName}\", e =>");
		sourceBuilder.AppendLine("        {");
		sourceBuilder.AppendLine($"            e.ConfigureConsumeTopology = false;");
		sourceBuilder.AppendLine("        });");
	}

	/// <summary>
	/// Represents information about a channel.
	/// </summary>
	private class ChannelInfo
	{
		public string EventName { get; set; } = string.Empty;
		public string ChannelName { get; set; } = string.Empty;
	}
}